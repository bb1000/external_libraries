<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
    </style>
    <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

  </head>
  <body>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
    <script src="/external_libraries/refreeze/js/springy.js"></script>
    <script src="/external_libraries/refreeze/js/springyui.js"></script>
    <script>
        
    </script>
    <textarea id="source">
name: inverse
layout: true
class: center, middle, inverse

---

&lt;script type=&#34;text/javascript&#34;
  src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#34;&gt;
&lt;/script&gt;
# External libraries

## 

BB1000 Programming in Python
KTH

---

layout: false

## Essential Python libraries

- NumPy: &#39;Numerical python&#39; - package for scientific computing in Python. Ment primarily to sort, reshape, and index array types...
- pandas: data structures and functions to work with structured data. The main object in pandas is the `DataFrame`, which is a two-dimentional tabular.
- matplotlib: producing plots; the basic functions handled in this course are all in the matplotlib.pyplot module.

```
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import matplotlib.pyplot as plt

```

&lt;!--
If ModuleNotFoundError, install first

import sys
!conda install --yes --prefix {sys.prefix} numpy (or pandas or matplotlib)

import pandas (or numpy or matplotlib.pyplot) as pd (or np or plt)

--&gt;


---

## NumPy

One of the key fatures of NumPy is its N-dimensional array object: `ndarray`. They enable to perform mathematical operations on blocks of data.

```
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; data1 = [6, 7.5, 8, 0, 1]
&gt;&gt;&gt; arr1 = np.array(data1)

&gt;&gt;&gt; print(arr1)
[ 6.   7.5  8.   0.   1. ]

&gt;&gt;&gt; data2 = [[1, 2, 3, 4], [ 5, 6, 7, 8]]
&gt;&gt;&gt; arr2 = np.array(data2)

&gt;&gt;&gt; print(arr2)
[[1 2 3 4]
 [5 6 7 8]] 

&gt;&gt;&gt; print(arr2.ndim)
2
&gt;&gt;&gt; print(arr2.shape)
(2, 4)

```

&lt;!--
np.ndarray(data2) does not work:

arr3= np.ndarray(data2)
TypeError: &#39;list&#39; object cannot be interpreted as an integer

--&gt;


---

## NumPy - Default arrays

```
&gt;&gt;&gt; print(np.zeros(10))
[ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]

&gt;&gt;&gt; print(np.zeros((3,6)))
[[ 0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.]]  

&gt;&gt;&gt; print(np.arange(15))
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]

```

&lt;!--
In [19]: print(np.ones(10))
[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]

In [21]: print(np.ones((3,6)))

[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
  [1. 1. 1. 1. 1. 1.]]

is not working with np.twos!

--&gt;

---

## NumPy - Default arrays

```
&gt;&gt;&gt; print(np.empty((2,3,2)))
[[[  2.35558336e-310   2.02731498e-316]
  [  2.35558575e-310   2.35558575e-310]
  [  2.35558575e-310   2.35558575e-310]]

 [[  2.35558575e-310   2.35558575e-310]
  [  2.35558575e-310   2.35558575e-310]
  [  2.35558575e-310   2.42092166e-322]]]

&gt;&gt;&gt; print(np.eye(3))
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]

```

`empty` creates an array without initializing its values to any particular value. It does the ideal recipe to return garbage...

---

## NumPy - Operations between arrays and scalars

```
&gt;&gt;&gt; arr = np.array([[1., 2., 3.], [4., 5., 6.]])
&gt;&gt;&gt; print(arr*arr)
[[  1.   4.   9.]
 [ 16.  25.  36.]]

&gt;&gt;&gt; print(arr-arr)
[[ 0.  0.  0.]
 [ 0.  0.  0.]]
 
&gt;&gt;&gt; print(1/arr)
[[ 1.          0.5         0.33333333]
 [ 0.25        0.2         0.16666667]]
 
&gt;&gt;&gt; print(arr**0.5)
[[ 1.          1.41421356  1.73205081]
 [ 2.          2.23606798  2.44948974]]
 
```
---

## NumPy - Basic indexing and slicing

```
&gt;&gt;&gt; arr= np.arange(10)
&gt;&gt;&gt; print(arr[5])
5
```

&lt;!--
In [34]: print(arr[10])
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
&lt;ipython-input-34-347682eaa77c&gt; in &lt;module&gt;()
  1 print(arr[10])

IndexError: index 10 is out of bounds for axis 0 with size 10
--&gt;

```
&gt;&gt;&gt; print(arr[5:8])
[5 6 7]
&gt;&gt;&gt; arr[5:8] = 12
&gt;&gt;&gt; print(arr)
[ 0  1  2  3  4 12 12 12  8  9]

&gt;&gt;&gt; arr_slice = arr[5:8]
&gt;&gt;&gt; arr_slice[:] = 64
&gt;&gt;&gt; print(arr)
[ 0  1  2  3  4 64 64 64  8  9]

```

&lt;!--
Slicing works in the same way as normal slicing:

In [35]: trysomething=[1,2,3,4,5,6,7,8]

In [36]: trysomething[2]
Out[36]: 3

In [37]: trysomething[2:5]
Out[37]: [3, 4, 5]

In [39]: trysomethingarray = np.array(trysomething)

In [40]: print(trysomethingarray[2:5])
[3 4 5]
--&gt;

&lt;!--
Assignments of values in lists is not possible like in arrays:

In [53]: trysomething[2:5] = 12

TypeError: can only assign an iterable
--&gt;

---

## NumPy - Basic indexing and slicing

```
&gt;&gt;&gt; arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&gt;&gt;&gt; print(arr2d[2])
[7 8 9]
&gt;&gt;&gt; print(arr2d[0][2])
3

```

&lt;!--
Basic indexing is the same as with lists:

In [58]: try2d = [[1,2,3],[4,5,6],[7,8,9]]

In [59]: try2d[2]
Out[59]: [7, 8, 9]

In [60]: try2d[0]
Out[60]: [1, 2, 3]

In [61]: try2d[0][2]
Out[61]: 3
--&gt;

```
&gt;&gt;&gt; print(arr2d[:2, 1:])
[[2 3]
 [5 6]]

```

&lt;!--
Entries up till (but not including) the second row are kept, as well as the column starting from (and including) the first one.

In [58]: try2d = [[1,2,3],[4,5,6],[7,8,9]]

In [62]: try2d[:2, 1:]
TypeError: list indices must be integers or slices, not tuple

Is something else then

In [63]: try2d[:2][1:]       
Out[63]: [[4, 5, 6]]

is somehow the same as (try2d[:2])[1:] 

In [64]: try2d[:2]
Out[64]: [[1, 2, 3], [4, 5, 6]]

--&gt;

---

## NumPy - Boolean indexing

```
&gt;&gt;&gt; names = np.array([&#39;Asterix&#39;, &#39;Obelix&#39;, &#39;Idefix&#39;, &#39;Asterix&#39;, &#39;Idefix&#39;,\
&#39;Obelix&#39;, &#39;Obelix&#39;])
&gt;&gt;&gt; names
array([&#39;Asterix&#39;, &#39;Obelix&#39;, &#39;Idefix&#39;, &#39;Asterix&#39;, &#39;Idefix&#39;, &#39;Obelix&#39;,
       &#39;Obelix&#39;],
      dtype=&#39;|S7&#39;)	     
&gt;&gt;&gt; names == &#39;Asterix&#39;
array([ True, False, False,  True, False, False, False], dtype=bool)

```

Remark that we print here the complete object. We can also just `print` the content:

```
&gt;&gt;&gt; print(names)
[&#39;Asterix&#39; &#39;Obelix&#39; &#39;Idefix&#39; &#39;Asterix&#39; &#39;Idefix&#39; &#39;Obelix&#39; &#39;Obelix&#39;]

&gt;&gt;&gt; print(names == &#39;Asterix&#39;)
[ True False False  True False False False]

```

---

## NumPy - Boolean indexing

```
&gt;&gt;&gt; data = np.random.randn(7,4)
&gt;&gt;&gt; data
array([[ 0.02062421, -0.1369847 ,  0.90160195,  0.75181516],
       [-1.1268401 , -0.41237719, -0.21513891,  0.2190537 ],
       [-0.00535594,  0.15848914, -0.99522448,  0.93785222],
       [ 0.84553696, -1.7851311 ,  0.74135975,  0.36109035],
       [ 1.22254501, -0.68403217,  0.39343747,  1.59037781],
       [ 0.02684093, -0.62523998,  0.06727077, -1.3981326 ],
       [ 0.70864672, -1.46741426, -1.69648987, -0.47846134]])

```

---

## NumPy - Boolean indexing

Those rows in data indexed with &#39;True&#39; can be selected:

```
&gt;&gt;&gt; data[names == &#39;Asterix&#39;]
array([[ 0.02062421, -0.1369847 ,  0.90160195,  0.75181516],
       [ 0.84553696, -1.7851311 ,  0.74135975,  0.36109035]])
       
```

And also slicing is possible:

```
&gt;&gt;&gt; data[names == &#39;Asterix&#39;, 2:]
array([[ 0.90160195,  0.75181516],
       [ 0.74135975,  0.36109035]])
       
```

For negation `!=` can be used as wel as `-` (in the newest numpy version, this is `~`)

```
&gt;&gt;&gt; names != &#39;Asterix&#39;
array([False,  True,  True, False,  True,  True,  True], dtype=bool)
&gt;&gt;&gt; data[-(names == &#39;Asterix&#39;)]
array([[-1.1268401 , -0.41237719, -0.21513891,  0.2190537 ],
       [-0.00535594,  0.15848914, -0.99522448,  0.93785222],
       [ 1.22254501, -0.68403217,  0.39343747,  1.59037781],
       [ 0.02684093, -0.62523998,  0.06727077, -1.3981326 ],
       [ 0.70864672, -1.46741426, -1.69648987, -0.47846134]])

```

---

## NumPy - Boolean indexing

To select two of the three names to combine multiple boolean conditions, use boolean arithmetic operators like `&amp;` (and) and `|` (or):

```
&gt;&gt;&gt; mask = (names == &#39;Asterix&#39;) | (names == &#39;Idefix&#39;)
&gt;&gt;&gt; mask
array([ True, False,  True,  True,  True, False, False], dtype=bool)

```

In this way, it is possible to set data to whole rows:

```
&gt;&gt;&gt; data[names != &#39;Asterix&#39;] = 7
&gt;&gt;&gt; data
array([[ 0.02062421, -0.1369847 ,  0.90160195,  0.75181516],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 0.84553696, -1.7851311 ,  0.74135975,  0.36109035],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ]])
					  
```

---

## NumPy - Transposing arrays

Arrays have the `transpose` method and also the special `T` attribute:

```
&gt;&gt;&gt; arr = np.arange(15).reshape((3,5))
&gt;&gt;&gt; arr
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
&gt;&gt;&gt; arr.T
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])			    

```

The method is very interesting in linear algebra, as the inner matrix product &#39;X^TX&#39; can be easily calculated:

```
&gt;&gt;&gt; np.dot(arr.T, arr)
array([[125, 140, 155, 170, 185],
       [140, 158, 176, 194, 212],
       [155, 176, 197, 218, 239],
       [170, 194, 218, 242, 266],
       [185, 212, 239, 266, 293]])

```

---

## NumPy - Unary and binary universal functions

A universal function (&#39;ufunction&#39;) is a function that performs elementwise operations on data in ndarrays. A unary one only focusses upon one array, while binary ones require 2 arrays.

Examples of unary ufunctions are `sqrt`, `exp`, `abs`, `log`, `sign`, `floor` (largest integer less than or equal to the element), `ceil` (analogon for `floor` but then higher or equal to the element), `cos`,...

Examples of binary ufunctions are `add`, `subtract`, `multiply`, `divide`, `power`, `maximum`, `minimum`, `mod` (remainder of division), `greater`, `less`, `less_equal`, ...


---

## NumPy - Unary and binary universal functions

A few examples...	

```
&gt;&gt;&gt; arr = np.arange(10)
&gt;&gt;&gt; np.sqrt(arr)
array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,
        2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])

```

```
&gt;&gt;&gt; arr2 = np.random.randn(10)
&gt;&gt;&gt; arr2
array([-1.32672421, -2.02196629, -1.87814963,  1.3586335 ,  0.66869694,
        1.64577817,  0.01575116,  0.09529667, -0.32427566,  0.73408638])
&gt;&gt;&gt; arr3 = np.random.randn(10)
&gt;&gt;&gt; arr3
array([-0.09059814, -0.05915682,  1.39919745, -0.96167955, -2.70897768,
       -1.44743637,  0.47766619, -0.18136026,  0.87246909, -0.43929249])
&gt;&gt;&gt; np.maximum(arr2, arr3)
array([-0.09059814, -0.05915682,  1.39919745,  1.3586335 ,  0.66869694,
        1.64577817,  0.47766619,  0.09529667,  0.87246909,  0.73408638])
	
```

---

## NumPy - Conditions and arrays

The `numpy.where(condition,firstargument,secondargument)` function reduces the expression `x if condition else y` for arrays: if the `condition` is true, then the `firstargument` is executed, else the `secondargument` is done.

```
&gt;&gt;&gt; xarr = np.array([1.1, 1.2, 1.3 , 1.4, 1.5])
&gt;&gt;&gt; yarr = np.array([2.1, 2.2, 2.3 , 2.4, 2.5])
&gt;&gt;&gt; cond = np.array([True, False, True, True, False])
&gt;&gt;&gt; result = np.where(cond, xarr, yarr)
&gt;&gt;&gt; result
array([ 1.1,  2.2,  1.3,  1.4,  2.5])

``` 

For boolean arrays, `any` tests whether one or more values in an array is `True`, while `all` checks if every value is `True`.

```
&gt;&gt;&gt; bools = np.array([False, False, True, False])
&gt;&gt;&gt; np.any(bools)
True
&gt;&gt;&gt; np.all(bools)
False

```

---

## NumPy - Sorting and Unique

```
&gt;&gt;&gt; arr= np.random.randn(8)
&gt;&gt;&gt; arr
array([ 0.71176752,  0.24762018, -0.61990769,  0.77071301,  0.67810754,
        1.92071058,  1.01916251,  1.06109087])
&gt;&gt;&gt; np.sort(arr)
array([-0.61990769,  0.24762018,  0.67810754,  0.71176752,  0.77071301,
        1.01916251,  1.06109087,  1.92071058])

```

```
&gt;&gt;&gt; names = np.array([&#39;Asterix&#39;, &#39;Kanalltix&#39;, &#39;Kaningentix&#39;, &#39;Asterix&#39;, \
&#39;Kaningentix&#39;, &#39;Asterix&#39;, &#39;Kaningentix&#39;])
&gt;&gt;&gt; np.unique(names)
array([&#39;Asterix&#39;, &#39;Kanalltix&#39;, &#39;Kaningentix&#39;],
      dtype=&#39;|S11&#39;)

```

---

## NumPy - Storing array, saving and loading

`np.save` and `np.load` allow to save and load data on disk. It will be in raw binary format and have file extension `.npy`.   

```
&gt;&gt;&gt; arr = np.arange(10)
&gt;&gt;&gt; np.save(&#39;some_array&#39;, arr)
&gt;&gt;&gt; np.load(&#39;some_array.npy&#39;)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

```

Heroix finds a paper with the service numbers of the roman soldiers which attacked his village yesterday. How can he manipulate this using arrays?

```
125481,568937,428937,585667,889375,442568,558937,557934,554723,258649,34582
&gt;&gt;&gt; arr = np.loadtxt(&#39;servicenumbers.txt&#39;, delimiter=&#39;,&#39;)
&gt;&gt;&gt; arr
array([ 125481.,  568937.,  428937.,  585667.,  889375.,  442568.,
        558937.,  557934.,  554723.,  258649.,   34582.])
	
```

When Heroix wants to write the service numbers of his Celtic warriors on a file, he uses `np.savetxt`:

```
&gt;&gt;&gt; arr2=np.random.randn(8)
&gt;&gt;&gt; np.savetxt(&#39;CelticWarr.txt&#39;,arr2)

```

---

## NumPy - Linear algebra

Attention has to be paid at `*` which is an element-wise product instead of a matrix dot product. The function `dot` is used in numpy (see &#39;Transposing arrays&#39;).

To do calculations on matrices, `numpy.linalg` has a standard set of functions, like `diag` (return the diagonal elements of a square matrix), `trace`, `det` (matrix determinant), `eig` (eigenvalues and eigenvectors of a square matrix), `inv` (inverse),...

```
&gt;&gt;&gt; X = np.random.randn(2,2)
&gt;&gt;&gt; mat = X.T.dot(X)
&gt;&gt;&gt; np.linalg.inv(mat)
array([[  1.70182387,   3.91458018],
       [  3.91458018,  10.22597796]])
       
```

---

## NumPy - cumsum()

The `cumsum()` function gives out the cumulative sum of the numbers in the array.

```
&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])
&gt;&gt;&gt; np.cumsum(a)
array([ 1,  3,  6, 10, 15, 21])
&gt;&gt;&gt; np.cumsum(a,axis=0)   #sum over columns
array([[1, 2, 3],
       [5, 7, 9]])
&gt;&gt;&gt; np.cumsum(a,axis=1)   #sum over rows
array([[ 1,  3,  6],
       [ 4,  9, 15]])

```

---

## Pandas - Series

A `Series` is a one-dimensional object containing an array of data and an associated array of data labels, called its index.

```
&gt;&gt;&gt; obj = pd.Series([4, 7, -5, 3])
&gt;&gt;&gt; obj
0    4
1    7
2   -5
3    3
dtype: int64
&gt;&gt;&gt; obj.values
array([ 4,  7, -5,  3])
&gt;&gt;&gt; obj.index 
RangeIndex(start=0, stop=4, step=1)
&gt;&gt;&gt; for j in obj.index : print(j)
0
1
2
3

```

---

## Pandas - Series

It is also possible to define the index.

```
&gt;&gt;&gt; obj2 = pd.Series([4, 7, -5, 3], index=[&#39;d&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;])
&gt;&gt;&gt; obj2
d    4
b    7
a   -5
c    3

```

Single values can be selected and assigned.

```
&gt;&gt;&gt; obj2[&#39;a&#39;]
-5
&gt;&gt;&gt; obj2[&#39;d&#39;] = 6

```

Numpy array operations are possible - the index value does not change.

```
&gt;&gt;&gt; np.exp(obj2)
d     403.428793
b    1096.633158
a       0.006738
c      20.085537
dtype: float64

```

---

## Pandas - DataFrame

A DataFrame represents a tabular, spreadsheet-like data structure which contains an ordered collection of columns, which can have a different value type (numeric, boolean,...). A DataFrame has both a row and a column index.

```
&gt;&gt;&gt; data = {&#39;Celt&#39;: [&#39;Asterix&#39;, &#39;Asterix&#39;, &#39;Asterix&#39;, &#39;Obelix&#39;, &#39;Obelix&#39;], &#39;age&#39; :
[18, 19, 20, 19, 20 ], &#39;numberofromans&#39;: [1.5, 1.7, 3.6, 2.4, 2.9]}
&gt;&gt;&gt; frame = pd.DataFrame(data)
&gt;&gt;&gt; frame
      Celt  age  numberofromans
0  Asterix   18             1.5
1  Asterix   19             1.7
2  Asterix   20             3.6
3   Obelix   19             2.4
4   Obelix   20             2.9

```

---

## Pandas - DataFrame

The sequence of columns can be specified and the index can be redefined.

```
&gt;&gt;&gt; frame2 = pd.DataFrame(data, columns=[&#39;numberofromans&#39;,&#39;Celt&#39;], index=[&#39;one&#39;,
&#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39;])
&gt;&gt;&gt; frame2
       numberofromans     Celt
one               1.5  Asterix
two               1.7  Asterix
three             3.6  Asterix
four              2.4   Obelix
five              2.9   Obelix
       
```

In order to write out the DataFrame, `to_csv` is used.

```
&gt;&gt;&gt; frame2.to_csv(&#39;out_frame2.csv&#39;)

```

---

## Pandas - DataFrame

Columns can be retrieved in two different ways.

```
&gt;&gt;&gt; frame2[&#39;Celt&#39;]
one      Asterix
two      Asterix
three    Asterix
four      Obelix
five      Obelix
Name: Celt, dtype: object
&gt;&gt;&gt; frame2.numberofromans
one      1.5
two      1.7
three    3.6
four     2.4
five     2.9
Name: numberofromans, dtype: float64

```

Rows can be retrieved by using `loc` and the index.

```
&gt;&gt;&gt; frame2.loc[&#39;three&#39;]
numberofromans        3.6
Celt              Asterix
Name: three, dtype: object

```

---

## Pandas - DataFrame

Assigning a column that doesn&#39;t exist will create a new column.

```
&gt;&gt;&gt; frame2[&#39;thick&#39;] = frame2.Celt == &#39;Obelix&#39;
&gt;&gt;&gt; frame2
              numberofromans     Celt  thick
       one               1.5  Asterix  False
       two               1.7  Asterix  False
       three             3.6  Asterix  False
       four              2.4   Obelix   True
       five              2.9   Obelix   True

```

`del` removes columns

```
&gt;&gt;&gt; del frame2[&#39;thick&#39;]
&gt;&gt;&gt; frame2
              numberofromans     Celt
       one               1.5  Asterix
       two               1.7  Asterix
       three             3.6  Asterix
       four              2.4   Obelix
       five              2.9   Obelix
       
```

---

## Pandas - Dataframe

Use can be made of nested structures:

```
&gt;&gt;&gt; punch = { &#39;Asterix&#39;: {18: 1.5, 19: 1.7, 20: 3.6}, &#39;Obelix&#39;: { 19: 2.4,
20: 2.9}} 
&gt;&gt;&gt; frame = pd.DataFrame(punch)
&gt;&gt;&gt; frame
        Asterix  Obelix
    18      1.5     NaN
    19      1.7     2.4
    20      3.6     2.9
    
```

... and it can be transposed

```
&gt;&gt;&gt; frame.T
    18   19   20
    Asterix  1.5  1.7  3.6
    Obelix   NaN  2.4  2.9
	  
```

---

## Pandas - Data alignment

```
&gt;&gt;&gt; A = pd.Series([7.3, -2.5, 3.4, 1.5], index = [&#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])
&gt;&gt;&gt; B = pd.Series([-2.1, 3.6, -1.5, 4, 3.1], index = [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;])
&gt;&gt;&gt; A+B
a    5.2
c    1.1
d    NaN
e    0.0
f    NaN
g    NaN
dtype: float64

```

Remark that d is missing in B, while f and g are absent in A.

---

## Pandas - Data alignment

```
&gt;&gt;&gt; df1 = pd.DataFrame(np.arange(9.).reshape(3, 3), columns=list(&#39;bcd&#39;),
index=[&#39;Asterix&#39;, &#39;Obelix&#39;, &#39;Kanalltix&#39;]) 
&gt;&gt;&gt; df2 = pd.DataFrame(np.arange(12.).reshape(4,3), columns=list(&#39;bde&#39;),
index=[&#39;Miraculix&#39;, &#39;Asterix&#39;, &#39;Obelix&#39;, &#39;Kaningentix&#39;])
&gt;&gt;&gt; df1
            b    c    d
Asterix   0.0  1.0  2.0
Obelix    3.0  4.0  5.0
Kanalltix  6.0  7.0  8.0	    
&gt;&gt;&gt; df2
               b     d     e
Miraculix    0.0   1.0   2.0
Asterix      3.0   4.0   5.0
Obelix       6.0   7.0   8.0
Kaningentix  9.0  10.0  11.0
&gt;&gt;&gt; df1+df2
               b   c     d   e
Asterix      3.0 NaN   6.0 NaN
Kanaltix     NaN NaN   NaN NaN
Kaningentix  NaN NaN   NaN NaN
Miraculix    NaN NaN   NaN NaN
Obelix       9.0 NaN  12.0 NaN
	       
```

---

## Pandas - Sorting

```
&gt;&gt;&gt; obj = pd.Series(range(4), index=[&#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
&gt;&gt;&gt; obj.sort_index()
a    1
b    2
c    3
d    0
dtype: int64
&gt;&gt;&gt; obj2 = pd.Series([ 4, 7, -3, 2], index=[&#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
&gt;&gt;&gt; obj2.sort_values()
b   -3
c    2
d    4
a    7
dtype: int64

```

---

## Pandas - Sorting

```
&gt;&gt;&gt; frame = pd.DataFrame(np.arange(8).reshape(2,4), index=[&#39;three&#39;, &#39;one&#39;],
columns=[&#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
&gt;&gt;&gt; frame.sort_index()     #The same as frame.sort_index(axis=0) 
       d  a  b  c
one    4  5  6  7
three  0  1  2  3
&gt;&gt;&gt; frame.sort_index(axis=1)
       a  b  c  d
three  1  2  3  0
one    5  6  7  4
&gt;&gt;&gt; frame.sort_index(axis=1, ascending=False)
       d  c  b  a
three  0  3  2  1
one    4  7  6  5
       
```

When Kanalltix wants to sort the values by a specified column, however, he cannot use `sort_index`, but has to revert to `sort_values(by= )`. 

```
&gt;&gt;&gt; frame = pd.DataFrame({&#39;b&#39;: [4, 7, -3], &#39;a&#39;: [0, 1, 0]})
&gt;&gt;&gt; frame.sort_values(by=&#39;b&#39;)
   a  b
2  0 -3
0  0  4
1  1  7
   
```

---

## Pandas - Baby names 1880-2015

On http://www.ssa.gov/oact/babynames/limits.html the total number of births for each gender/name combination is given as a raw archive. 

```
Mary,F,7065
Anna,F,2604
Emma,F,2003
Elizabeth,F,1939
Minnie,F,1746

```

Since this is a comma-separated form, use is made of `pandas.read_csv` to load the data

```
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; names1880 = pd.read_csv(&#39;Names/yob1880.txt&#39;, names=[&#39;name&#39;, &#39;sex&#39;, &#39;births&#39;])

```

---

The data are printed as

```
&gt;&gt;&gt; print(names1880)
         name sex  births
0        Mary   F    7065
1        Anna   F    2604
2        Emma   F    2003
3        Elizabeth   F    1939
4        Minnie   F    1746
...
1996     Worthy   M       5
1997     Wright   M       5
1998       York   M       5
1999  Zachariah   M       5

[2000 rows x 3 columns]

```

To get an overview over all births, we can use the sum of the births by sex:

```
&gt;&gt;&gt; names1880.groupby(&#39;sex&#39;)[&#39;births&#39;].sum()
sex
F     90992
M    110490
Name: births, dtype: int64

```

---

## Pandas - Excel

On the internet, Kaningentix finds an excel sheet containing all herbs, grasses and vegetables which can be found in the forest. The list contains not only the names and the subsequent characterizations, but also where these are found and the time of the medicinal effect.

It is advisable to use pandas, making use of the `read_excel` function.

```
&gt;&gt;&gt; table = pd.read_excel(&#39;data.xlsx&#39;)
&gt;&gt;&gt; table
      herb  color  place          why?
0    grass   green  river  knee injury
1  mushroom  brown   tree     headache
      
```



&lt;!--

It is advisable to use pandas, making use of the ExcelFile class.


```
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; xls_file = pd.ExcelFile(&#39;data.xls&#39;) 

```

Data stored in a sheet can then be read into DataFrame using parse:

```
&gt;&gt;&gt; table = xls_file.parse(&#39;Sheet1&#39;)

```

--&gt;

---

## Matplotlib

Basic syntax for a plot

```
&gt;&gt;&gt; plt.plot(np.random.randn(30), linestyle=&#39;--&#39;, color=&#39;g&#39;)
&gt;&gt;&gt; plt.show()

```

&lt;img src=&#34;img/figure_A.png&#34; height=&#34;125&#34;/&gt;

Other styles and colors are available and can easily be searched. 

```
&gt;&gt;&gt; plt.plot(np.random.randn(30).cumsum(), color=&#39;k&#39;, linestyle=&#39;solid&#39;,
marker=&#39;*&#39;)
&gt;&gt;&gt; plt.show()

```

&lt;img src=&#34;img/figure_B.png&#34; height=&#34;125&#34;/&gt;



---

## Matplotlib - Figures and subplots

To manipulate figures, use is made of a `Figure` &#39;object&#39;.

```
&gt;&gt;&gt; fig = plt.figure()

```

Subplots are made using `add_subplot`. 

```
&gt;&gt;&gt; ax1 = fig.add_subplot(2,2,1)
&gt;&gt;&gt; ax2 = fig.add_subplot(2,2,2)
&gt;&gt;&gt; ax3 = fig.add_subplot(2,2,3)

```

The first two arguments of `subplot` point at the amount of pictures in one row and in one column. The last argument counts: left above is picture 1, right above is picture 2, left down is 3 etc.

&lt;img src=&#34;img/empty_plot.png&#34; height=&#34;160&#34;/&gt;

Techniques to fill these plots will be given in the following slides.

---

## Matplotlib - title, axis labels, ticks, and ticklabels

To adjust the axes, it is a good idea to use `add_subplot` - even when there is only one plot in the figure.

```
&gt;&gt;&gt; fig= plt.figure(); ax = fig.add_subplot(1, 1, 1)
&gt;&gt;&gt; ax.plot(np.random.randn(1000).cumsum())
[&lt;matplotlib.lines.Line2D at 0x2ab9f8ee0fd0&gt;]
&gt;&gt;&gt; ticks = ax.set_xticks([0, 250, 500, 750, 1000])
&gt;&gt;&gt; labels = ax.set_xticklabels([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39;],
rotation=30, fontsize=&#39;small&#39;)
&gt;&gt;&gt; ax.set_title(&#39;One of my first matplotlib plots&#39;)
&lt;matplotlib.text.Text at 0x2ab9f9648c50&gt;
&gt;&gt;&gt; ax.set_xlabel(&#39;Stages&#39;)


```

&lt;img src=&#34;img/figure_C.png&#34; height=&#34;250&#34;/&gt;

---

## Matplotlib - adding legends

Adding a legend is only possible when more than one plot is included in the graphic.

```
&gt;&gt;&gt; fig = plt.figure(); ax = fig.add_subplot(1, 1, 1)
&gt;&gt;&gt; ax.plot(np.random.randn(1000).cumsum(), &#39;k&#39;, label=&#39;one&#39;)
[&lt;matplotlib.lines.Line2D at 0x2ab9f9aaae50&gt;]
&gt;&gt;&gt; ax.plot(np.random.randn(1000).cumsum(), &#39;k--&#39;, label=&#39;two&#39;)
[&lt;matplotlib.lines.Line2D at 0x2ab9f9dbd150&gt;]
&gt;&gt;&gt; ax.plot(np.random.randn(1000).cumsum(), &#39;k.&#39;, label=&#39;three&#39;)
[&lt;matplotlib.lines.Line2D at 0x2ab9f9aa96d0&gt;]
&gt;&gt;&gt; ax.legend(loc=&#39;best&#39;)

```

&lt;img src=&#34;img/figure_D.png&#34; height=&#34;175&#34;/&gt;

---

## Matplotlib - Saving plots to a file

To save the figure on the last figure, `savefig` can be used. Pay attention to the extension - `.png`, `.jpg` and `.pdf` give the respective format of the pictures. The resolution can be indicated using `dpi`.

```
&gt;&gt;&gt; plt.savefig(&#39;myfavouritelastpic.png&#39;, dpi=400)

```

---

## Matplotlib - Plotting functions in Pandas

### Line plots

```
&gt;&gt;&gt; s= pd.Series(np.random.randn(10).cumsum(), index=np.arange(0, 100, 10))
&gt;&gt;&gt; s.plot()

```

&lt;img src=&#34;img/series_lineplots.png&#34; height=&#34;110&#34;/&gt;

```
&gt;&gt;&gt; df = pd.DataFrame(np.random.randn(10, 4).cumsum(0),
columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], index=np.arange(0, 100, 10))
&gt;&gt;&gt; df.plot()

```

&lt;img src=&#34;img/dataframe_lineplots.png&#34; height=&#34;110&#34;/&gt;

---

## Matplotlib - Plotting functions in Pandas

### Bar plots

```
&gt;&gt;&gt; data = pd.Series(np.random.rand(16), index=list(&#39;abcdefghijklmnopq&#39;))
&gt;&gt;&gt; data.plot(kind=&#39;barh&#39;, color=&#39;r&#39;, alpha=0.5)

```

&lt;img src=&#34;img/series_barplotsII.png&#34; height=&#34;210&#34;/&gt;

`alpha` points at the intensity of the red color.

---

## Matplotlib - Plotting functions in Pandas

### Bar plots

```
&gt;&gt;&gt; df = pd.DataFrame(np.random.rand(6,4), index= [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;,
&#39;five&#39;, &#39;six&#39;], columns=pd.Index([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], name=&#39;Genus&#39;))
&gt;&gt;&gt; df
Genus         A         B         C         D
one    0.430194  0.264419  0.863249  0.309548
two    0.053039  0.283306  0.958429  0.317259
three  0.525248  0.218834  0.334936  0.772332
four   0.282869  0.086094  0.745032  0.680265
five   0.667275  0.258653  0.241644  0.185485
six    0.979554  0.787525  0.840468  0.261518
&gt;&gt;&gt; df.plot(kind=&#39;bar&#39;)

```

&lt;img src=&#34;img/dataframe_barplots.png&#34; height=&#34;210&#34;/&gt;

---

## Matplotlib - Total births by gender and year

From 1880 to 2015, a file is available containing the year of birth, together with the amount of born females and males.

```
&gt;&gt;&gt; tb=pd.read_csv(&#39;out_total_births.csv&#39;)
&gt;&gt;&gt; tb
     year        F        M
0    1880    90992   110490
1    1881    91953   100743
2    1882   107848   113686
3    1883   112318   104627
..    ...      ...      ...
133  2013  1747544  1883945
134  2014  1777242  1910876
135  2015  1769325  1898858

[136 rows x 3 columns]

&gt;&gt;&gt; tb.plot(title=&#39;Total births by sex and year&#39;, x=&#39;year&#39;,y=[&#39;F&#39;,&#39;M&#39;])

```

---

## Matplotlib - Total births by gender and year

&lt;img src=&#34;img/dataframe_tb.png&#34; height=&#34;480&#34;/&gt;

---

## PIP

Pip is a package management system used to install and manage software packages written in Python, taken from the `Python Package Index&#39; (PyPI).

Use:

```
$ pip3 install package-name
$ pip3 uninstall package-name

```

---

## Virtual environments

Miraculix has been coding a lot throughout his life. He has programs made from the early days of Python - and he has ones which he made yesterday. To avoid compatibility issues (&#34;program Herbs1.py needs the module ColorGrass-1.0.2, while program IdefixIllness.py needs the module ColorGrass-12.1.15b&#34;), Miraculix uses `virtual environments` in which he can load the exact packages he needs.

```
$ which python3
/usr/bin/python3
$ python3 -m venv ./venv
$ source venv/bin/activate
(venv)$ which python3
.../venv/bin/python3
(venv)$ which pip3
.../venv/bin/pip3
(venv)$ pip3 install ColorGrass-1.0.2

```

&lt;!--
Illustration with BeautifulSoup4 (bs4):

pip3 install BeautifulSoup4

story.py:
from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, &#39;html.parser&#39;)
print(soup.prettify())
--&gt;

... and Miraculix makes sure he is aware of the employed packages:

```
(venv)$ pip3 freeze &gt; requirements.txt

```


---

## References

&#34;Python for Data Analysis&#34;, Wes McKinney, O&#39;Reilly Media, Sebastopol, CA: 2013

https://docs.python.org/3/

https://matplotlib.org/gallery.html
    </textarea>

    <script src="/external_libraries/refreeze/js/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script src="/external_libraries/refreeze/js/high.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
          highlightStyle: 'sunburst',
          highlightLanguage: 'remark'
        }) ;
    </script>
  </body>
</html>